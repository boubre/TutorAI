using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Threading;
using GeometryTutorLib.Pebbler;

namespace GeometryTutorLib.ProblemAnalyzer
{
    public class PathGenerator
    {
        // Matrix to indicate if, from a node, we can reach another node.
        //private bool[,] reachable;
        //private SharedPebbledNodeList sharedEdgeList;
        //private List<PebblerHyperEdge> edges;

        //private GeneratorHashtable forwardProblems;
        //private PathHashMap forwardPathHashMap;
        //public List<Problem> GetProblems() { return problems.GetProblems(); }

        // The original graph in order to have information about node types; right now just axiomatic
        Hypergraph.Hypergraph<ConcreteAST.GroundedClause, int> graph;
        private readonly int GRAPH_DIAMETER;
        public PathGenerator(Hypergraph.Hypergraph<ConcreteAST.GroundedClause, int> g /*, SharedPebbledNodeList sharedData */)
        {
            graph = g;
            GRAPH_DIAMETER = g.vertices.Count;
            
            //forwardProblems = new GeneratorHashtable(50);
            //forwardPathHashMap = new PathHashMap(graph.Size());
            
            //reachable = new bool[n, n];
            //edges = new List<PebblerHyperEdge>();
            /* sharedEdgeList = sharedData; */
        }

        //
        // Given a start node, construct a path using reachability analysis to construct a path from start template node back to leaves.
        // Forward problems are generated by following forward edges in reverse
        //
        //                                      A multimap of all pebbled edges (from pebbling)
        public List<Problem> GenerateForwardProblemsUsingBackwardPathToLeaves(PebblerHypergraph<ConcreteAST.GroundedClause> pebbler, int startNode)
        {
            return TraverseBackwardPathToLeaves(pebbler, startNode, new Problem());
        }
        //
        // Main backward reachability code
        //
        public List<Problem> TraverseBackwardPathToLeaves(PebblerHypergraph<ConcreteAST.GroundedClause> pebbler, int startNode, Problem problem)
        {
            List <Problem> newProblems = new List<Problem>();

            // Acquire all possible edges which lead to the start node
            List<PebblerHyperEdge> backwardEdges = pebbler.forwardPebbledEdges.GetBasedOnGoal(startNode);

            //
            // Is this a direct leaf node?
            //
            if (backwardEdges == null) return newProblems;
            if (!backwardEdges.Any()) return newProblems;

            // Spin (recursively) until a fixpoint where we find all leaf nodes
            foreach (PebblerHyperEdge edge in backwardEdges)
            {
                // The outgoing edge needs to be a forward edge
                if (edge.IsEdgePebbledForward())
                {
                    // Each distinct edge represents a new Problem (path in the graph); but, it is not an interesting problem
                    // Problem newEdgeProblem = new Problem(edge.sourceNodes, edge.targetNode);
                    // An interesting problem, by definition has path length > 0
                    // newProblems.Add(newEdgeProblem);
                    Problem copyProblem = new Problem(problem);
                    copyProblem.CombineWithEdge(edge.sourceNodes, edge.targetNode);
                    copyProblem.AddEdge(edge);

                    //
                    // Avoid any simple cycles
                    //
                    if (!copyProblem.ContainsCycle())
                    {
                        newProblems.Add(copyProblem);

                        //if (copyProblem.ContainsCycle())
                        //{
                        //    Debug.WriteLine(copyProblem.EdgeAndSCCDump());

                        //    throw new Exception("Problem has a cycle: " + copyProblem);
                        //}

                        //
                        // Check if we have all 'leaf' nodes from this hyperedge in the graph; this avoids cycling in any paths
                        // Intrinsic nodes are leaf nodes here since we are considering only 'forward' problems
                        //
                        bool intrinsicSet = true;
                        foreach (int src in edge.sourceNodes)
                        {
                            if (!graph.GetNode(src).IsIntrinsic())
                            {
                                intrinsicSet = false;
                                break;
                            }
                        }

                        // If we have not hit the leaves, recur
                        if (!intrinsicSet)
                        {
                            foreach (int src in edge.sourceNodes)
                            {
                                newProblems.AddRange(TraverseBackwardPathToLeaves(pebbler, src, copyProblem));
                            }
                        }
                    }
                }
            }

            return newProblems;
        }

        //
        // Given a start node, construct a path using reachability analysis to construct a path from start template node back to leaves.
        //
        //                                      A multimap of all pebbled edges (from pebbling)
        public List<Problem> GenerateBackwardProblemsUsingBackwardPathToNonLeaves(PebblerHypergraph<ConcreteAST.GroundedClause> pebbler, int startNode)
        {
            return TraverseBackwardPathToNonLeaves(pebbler, startNode, new Problem(), 0);
        }
        //
        // Main backward reachability code
        //
        public List<Problem> TraverseBackwardPathToNonLeaves(PebblerHypergraph<ConcreteAST.GroundedClause> pebbler, int startNode, Problem problem, int numNodesVisited)
        {
            List<Problem> newProblems = new List<Problem>();

            // Stop analysis if we have visited all nodes in the graph.
            if (numNodesVisited > GRAPH_DIAMETER - 1) return newProblems;

            // Acquire all possible edges which lead to the start node
            List<PebblerHyperEdge> backwardEdges = pebbler.backwardPebbledEdges.GetBasedOnGoal(startNode);

            //
            // Is this a direct non-leaf node with no more backward edges?
            //
            if (backwardEdges == null) return newProblems;
            if (!backwardEdges.Any()) return newProblems;

            // Spin (recursively) until a fixpoint where we find all non-leaf nodes
            foreach (PebblerHyperEdge edge in backwardEdges)
            {
                // The outgoing edge needs to be a backward edge
                if (edge.IsEdgePebbledBackward() && !edge.sourceNodes.Contains(problem.goal) && !problem.edges.Contains(edge) && !problem.ContainsGoalEdge(edge.targetNode))
                {
                    // Each distinct edge represents a new Problem (path in the graph); but, it is not an interesting problem
                    // Problem newEdgeProblem = new Problem(edge.sourceNodes, edge.targetNode);
                    // An interesting problem, by definition has path length > 0
                    // newProblems.Add(newEdgeProblem);
                    Problem copyProblem = new Problem(problem);
                    copyProblem.CombineWithEdge(edge.sourceNodes, edge.targetNode);
                    copyProblem.AddEdge(edge);

                    //
                    // Avoid any problem with a cycle
                    //
                    if (!copyProblem.ContainsCycle())
                    //{
                    //    Debug.WriteLine(copyProblem.EdgeAndSCCDump());

                    //    throw new Exception("Problem has a cycle: " + copyProblem);
                    //}
                    //else
                    {
                        //
                        // We have a new problem; recur on it
                        //
                        newProblems.Add(copyProblem);

                        //
                        // Check if we have all red or purple nodes from this hyperedge 
                        // These are considered 'leaf' nodes in this backward analysis
                        //
                        bool LeafSet = true;
                        foreach (int src in edge.sourceNodes)
                        {
                            if (pebbler.vertices[src].pebble != PebblerColorType.RED_FORWARD)
                            {
                                LeafSet = false;
                                break;
                            }
                        }

                        // If we have not hit the 'leaves', recur
                        if (!LeafSet)
                        {
                            foreach (int src in edge.sourceNodes)
                            {
                                newProblems.AddRange(TraverseBackwardPathToNonLeaves(pebbler, src, copyProblem, numNodesVisited + 1));
                            }
                        }
                        //bool intrinsicSet = true;
                        //foreach (int src in edge.sourceNodes)
                        //{
                        //    if (!graph.GetNode(src).IsIntrinsic())
                        //    {
                        //        intrinsicSet = false;
                        //        break;
                        //    }
                        //}

                        //// If we have not hit the leaves, recur
                        //if (!intrinsicSet)
                        //{
                        //    foreach (int src in edge.sourceNodes)
                        //    {
                        //        newProblems.AddRange(TraverseBackwardPathToLeaves(pebbler, src, combined));
                        //    }
                        //}
                    }
                }
            }

            return newProblems;
        }


        ////
        //// Acquire the next problem if we consider the number of source nodes.
        ////
        //private const int MAX_SOURCE_NODES = 6;
        //private Problem GetNextProblem(List<Problem> worklist)
        //{
        //    if (!worklist.Any()) return null;

        //    // Seek the next viable problem
        //    int w = 0;
        //    for ( ; w < worklist.Count; w++)
        //    {
        //        if(worklist[w].givens.Count <= MAX_SOURCE_NODES &&            worklist[w].goal <= 70)
        //        {
        //            break;
        //        }
        //    }

        //    // If there are no valid problems
        //    if (w == worklist.Count)
        //    {
        //        // Remove all problems from the worklist returning an invalid next problem
        //        worklist.Clear();
        //        return null;
        //    }

        //    // Take that one valid problem and remove all elements from the list up to that problem (including that problem)
        //    Problem next = worklist[w];
        //    if (w == 0) worklist.RemoveAt(0);
        //    else if (w == worklist.Count) worklist.Clear();  // These statements are overkill I am sure.
        //    else worklist.RemoveRange(0, w+1);

        //    return next;
        //}

        ////
        //// If U |- n is a problem:
        ////   let v \in U such that V |- v is a problem then
        ////   generate a new problem: (U \ v) \bigcup V |- n provided: (U \ v) \bigcup V != { n } AND 
        ////
        //private int probCount = 1;
        //public void GeneratePaths(Problem firstNewProblem)
        //{
        //    List<Problem> worklist = new List<Problem>();
        //    worklist.Add(firstNewProblem);

        //    while (worklist.Any())
        //    {
        //        // Acquire a new element to work on
        //        Problem thisNewProblem = GetNextProblem(worklist);
        //        if (thisNewProblem == null) return;

        //        Debug.WriteLine("Considering (" + (probCount++) + "): " + thisNewProblem);

        //        // Acquire the old problems in which we can combine with the problem under consideration
        //        List<Problem> oldApplicableProblems = pathHashMap.Get(thisNewProblem.goal);

        //        if (oldApplicableProblems != null)
        //        {
        //            foreach (Problem oldProblem in oldApplicableProblems)
        //            {
        //                // Can we combine? That is, is the new goal in the old source; even more specifically,
        //                // avoid a cycle by checking that the old goal is not in the thisNew source
        //                if (!thisNewProblem.InSource(oldProblem.goal) && !thisNewProblem.InPath(oldProblem.goal))
        //                {
        //                    // To avoid a cycle, avoid deducing this same node
        //                    if (!oldProblem.HasGoal(thisNewProblem.goal))
        //                    {
        //                        Utilities.AddUnique(worklist, oldProblem.CombineAndCreateNewProblem(thisNewProblem));
        //                    }
        //                }
        //            }
        //        }

        //        // Add this new edge as a problem, but avoid redundancy
        //        if (!problems.Contains(thisNewProblem))
        //        {
        //            pathHashMap.Put(thisNewProblem);
        //            problems.Put(thisNewProblem);
        //        }
        //        //else
        //        //{
        //        //    Debug.WriteLine("Deduced already: " + thisNewProblem.ToString());
        //        //}
        //    }
        //}

        ////
        //// Adds a hyperedge to the reachability matrix as well as the predecessor matrix
        ////
        //public void AddEdge(PebblerHyperEdge edge)
        //{
        //    Debug.WriteLine("Considering Edge: " + edge.ToString());
        //    AddToReachability(edge);

        //    edges.Add(edge);
        //    GeneratePaths(new Problem(edge.sourceNodes, edge.targetNode, edges.Count));
        //}

        ////
        //// Consumer thread executes this method
        ////
        //public void GenerateAllPaths()
        //{
        //    //while (!sharedEdgeList.IsReadingAndWritingComplete()) // busy waiting?
        //    //{
        //    //    // Acquire the new edge
        //    //    PebblerHyperEdge edge = sharedEdgeList.ReadEdge();

        //    //    // Prohibit generating any problem in which an axiomatic node is a goal.
        //    //    if (!graph.GetNode(edge.targetNode).IsAxiomatic())
        //    //    {
        //    //        // Create the corresponding problem
        //    //        Problem newProblem = new Problem(edge.sourceNodes, edge.targetNode, problems.size);

        //    //        // Create the problem paths / solutions
        //    //        GeneratePaths(newProblem);
        //    //    }
        //    //}

        //    Debug.WriteLine("-------------------");
        //    foreach (Problem problem in problems.GetProblems())
        //    {
        //        Debug.WriteLine(problem.ToString());
        //    }

        //    //Debug.WriteLine("Path Map (Size: " + pathHashMap.size + "): \n" + pathHashMap.ToString());
        // }

        ////
        //// Adds a hyperedge to the reachability matrix; [r, c] indicates is there exists a path from r -> c
        ////
        //private void AddToReachability(PebblerHyperEdge edge)
        //{
        //    //
        //    // for each node in the source list, indicate that they can reach the target.
        //    //
        //    // Create a single edge path
        //    Path newP = new Path(Utilities.MakeList<PebblerHyperEdge>(edge));
        //    foreach (int src in edge.sourceNodes)
        //    {
        //        reachable[src, edge.targetNode] = true;
        //        Debug.WriteLine("Setting <" + src + ", " + edge.targetNode + ">");

        //        //paths[src, edge.targetNode].Add(newP); // What about target?
        //    }

        //    //
        //    // Any predecessor of a source node can now reach the target.
        //    //
        //    foreach (int src in edge.sourceNodes)
        //    {
        //        for (int r = 0; r < reachable.GetLength(0); r++)
        //        {
        //            if (reachable[r, src])
        //            {
        //                reachable[r, edge.targetNode] = true;
        //            }
        //        }
        //    }

        //    //
        //    // Any successor of the target can now be reached by the source nodes
        //    //
        //    foreach (int src in edge.sourceNodes)
        //    {
        //        for (int r = 0; r < reachable.GetLength(0); r++)
        //        {
        //            if (reachable[edge.targetNode, r])
        //            {
        //                reachable[src, r] = true;
        //            }
        //        }
        //    }
        //}

        ////
        //// For demonstration purposes of all the generated problems.
        ////
        //public void PrintAllProblemsAndSolutions()
        //{
        //    Debug.WriteLine("\n---------- Problems / Path / Goal ---------\n");
        //    List<Problem> probs = problems.GetProblems();
        //    for (int p = 0; p < probs.Count; p++)
        //    {
        //        Debug.WriteLine(p + " " + probs[p].ConstructProblemAndSolution(graph) + "\n");
        //    }
        //}

        //public override string ToString()
        //{
        //    StringBuilder s = new StringBuilder();

        //    // Print the reachability matrix
        //    s.Append("   ");
        //    for (int c = 0; c < reachable.GetLength(1); c++)
        //    {
        //        s.Append((c % 10) + " ");
        //    }
        //    s.AppendLine();
        //    for (int r = 0; r < reachable.GetLength(0); r++)
        //    {
        //        s.Append(r + ": ");
        //        for (int c = 0; c < reachable.GetLength(1); c++)
        //        {
        //            s.Append((reachable[r, c] ? "T" : "F") + " ");
        //        }
        //        s.AppendLine();
        //    }


        //    //
        //    // Print all paths
        //    //
        //    //s.AppendLine();
        //    //for (int r = 0; r < reachable.GetLength(0); r++)
        //    //{
        //    //    for (int c = 0; c < reachable.GetLength(1); c++)
        //    //    {
        //    //        if (paths[r, c].Any())
        //    //        {
        //    //            s.AppendLine("<" + r + ", " + c + ">: ");
        //    //            foreach (Path path in paths[r, c])
        //    //            {
        //    //                s.AppendLine("\t" + path.ToString());
        //    //            }
        //    //        }
        //    //    }
        //    //    s.AppendLine();
        //    //}

        //    return s.ToString();
        //}
    }
}
