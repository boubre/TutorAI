<<<<<<< HEAD
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GeometryTutorLib.ConcreteAST;
=======
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GeometryTutorLib.ConcreteAbstractSyntax;
>>>>>>> 8397a84bc91d81552eda116a1a78e6dec9a77895


namespace GeometryTutorLib.GenericInstantiator
{


    public class CongruentAnglesParallelIntersection : Theorem
    {
<<<<<<< HEAD
        private readonly static string NAME = "Alternate Interior Angles of Parallel Lines are Congruent";
=======
        private readonly static string NAME = "Congruent Alternate Interior Angles from Parallel Intersection";
>>>>>>> 8397a84bc91d81552eda116a1a78e6dec9a77895

        public CongruentAnglesParallelIntersection() { }

        private static List<Intersection> candIntersection = new List<Intersection>(); //All intersections found
        private static List<Parallel> candParallel = new List<Parallel>();  //All parallel sets found

        private static List<GroundedClause> antecedent;
<<<<<<< HEAD

=======
        
>>>>>>> 8397a84bc91d81552eda116a1a78e6dec9a77895

        //TODO: this currently describes something else
        // Intersect(X, Segment(A, B), Segment(C, D)) -> Congruent(Angle(A, X, C), Angle(B, X, D)),
        //                                               Congruent(Angle(A, X, D), Angle(C, X, B))
        //
        public static List<KeyValuePair<List<GroundedClause>, GroundedClause>> Instantiate(GroundedClause c)
        {
<<<<<<< HEAD
            List<Intersection> foundCand = new List<Intersection>(); //Variable holding intersections that will used for theorem

            //Exit if c is neither a parallel set nor an intersection
            if (!(c is Parallel) && !(c is Intersection)) return new List<KeyValuePair<List<GroundedClause>, GroundedClause>>();

=======
            
            //Exit if c is neither a parallel set nor an intersection
            if (!(c is Parallel) && !(c is Intersection)) return new List<KeyValuePair<List<GroundedClause>, GroundedClause>>();

            List<Intersection> foundCand = new List<Intersection>(); //Variable holding intersections that will used for theorem
            Parallel foundParallelSet = null;
            ConcreteSegment foundTransversal;

>>>>>>> 8397a84bc91d81552eda116a1a78e6dec9a77895
            // The list of new grounded clauses if they are deduced
            List<KeyValuePair<List<GroundedClause>, GroundedClause>> newGrounded = new List<KeyValuePair<List<GroundedClause>, GroundedClause>>();

            if (c is Parallel)
            {
                Parallel newParallel = (Parallel)c;
                candParallel.Add((Parallel)c);

<<<<<<< HEAD
                antecedent = Utilities.MakeList<GroundedClause>(newParallel);  //TODO: Find out what antecedent is used for

                //Find all intersections that contain one of the parallel segments in newParallel
                IEnumerable<Intersection> query = (IEnumerable<Intersection>)candIntersection.Where(m => m.lhs == newParallel.segment1 || m.rhs == newParallel.segment1 || m.lhs == newParallel.segment2 || m.rhs == newParallel.segment2);

                //Make list of intersections in new list that contain an identical value on the left and right side 
                foreach (Intersection inter in query)
                {
                    //TODO: Make more logical search
                    if ((query.Any(m => m.rhs == inter.lhs || m.lhs == inter.rhs || m.lhs == inter.lhs && m.rhs != inter.rhs || m.rhs == inter.rhs && m.lhs != inter.lhs)))
                    {
                        foundCand.Add(inter);  //This will be the pair of intersections on the set of parallel lines
=======
                //Create a list of all segments in the intersection list by individual segment and list of intersecting segments
                var query1 = candIntersection.GroupBy(m => m.lhs, m => m.rhs).Concat(candIntersection.GroupBy(m => m.rhs, m => m.lhs));

                //Iterate through all segments intersected by each key segment
                foreach (var group in query1)
                {
                    if (group.Contains(newParallel.segment1) && group.Contains(newParallel.segment2))
                    {
                        //If a segment that intersected both parallel lines was found, find the intersection objects.  
                        var query2 = candIntersection.Where(m => m.lhs.Equals(group.Key)).Concat(candIntersection.Where(m => m.rhs.Equals(group.Key)));
                        var query3 = candIntersection.Where(m => m.lhs.Equals(newParallel.segment1) || m.lhs.Equals(newParallel.segment2) || m.rhs.Equals(newParallel.segment1) || m.rhs.Equals(newParallel.segment2));
                        foundCand.AddRange(query3);

                        foundParallelSet = newParallel;
                        foundTransversal = group.Key;
                        

                        antecedent = Utilities.MakeList<GroundedClause>(newParallel); //Add parallel set to antecedents
                        
>>>>>>> 8397a84bc91d81552eda116a1a78e6dec9a77895
                    }
                }

            }
            else if (c is Intersection)
            {

                candIntersection.Add((Intersection)c);
                Intersection newintersect = (Intersection)c;

<<<<<<< HEAD
                antecedent = Utilities.MakeList<GroundedClause>(newintersect);

                //Make a list of intersections that have one of the segments contained in the new intersection
                IEnumerable<Intersection> intersectsList = (IEnumerable<Intersection>)candIntersection.Where(m => m.lhs == newintersect.lhs || m.lhs == newintersect.rhs || m.rhs == newintersect.lhs || m.rhs == newintersect.rhs);


                foreach (Parallel p in candParallel)
                {
                    foreach (Intersection inter in intersectsList)
                    {
                        ////TODO: Make more logical search
                        if (intersectsList.Any(m => m.rhs == inter.lhs || m.lhs == inter.rhs || m.lhs == inter.lhs && m.rhs != inter.rhs || m.rhs == inter.rhs && m.lhs != inter.lhs))
                        {
                            foundCand.Add(inter);
                        }
                    }
                }
            }


            //TODO: Make sure there will only be one set of intersections found at a time
            if (foundCand.Count() > 1)
            {

                CongruentAngles cca1;
                CongruentAngles cca2;

                //TODO: Not sure how math works here
                Angle ang1Set1 = new Angle(foundCand[0].lhs.Point1, foundCand[0].intersect, foundCand[0].rhs.Point1);
                Angle ang2Set1 = new Angle(foundCand[0].lhs.Point2, foundCand[0].intersect, foundCand[0].rhs.Point1);
                Angle ang1Set2 = new Angle(foundCand[1].lhs.Point1, foundCand[1].intersect, foundCand[1].rhs.Point1);
                Angle ang2Set2 = new Angle(foundCand[1].lhs.Point2, foundCand[1].intersect, foundCand[1].rhs.Point1);

                //Decide which angles match, cover perpendicular case
                if (ang1Set1.measure <= ang2Set1.measure)
                {
                    if (ang1Set2.measure <= ang2Set2.measure)
                    {
                        cca1 = new CongruentAngles(ang1Set1, ang1Set2, NAME);
                        cca2 = new CongruentAngles(ang2Set1, ang2Set2, NAME);
                    }
                    else
                    {
                        cca1 = new CongruentAngles(ang1Set1, ang2Set2, NAME);
                        cca2 = new CongruentAngles(ang2Set1, ang1Set2, NAME);
=======
                var query1 = candIntersection.GroupBy(m => m.lhs, m => m.rhs).Concat(candIntersection.GroupBy(m => m.rhs, m => m.lhs));

                foreach (Parallel p in candParallel)
                {
                    foreach (var group in query1)
                    {
                        if (group.Contains(p.segment1) && group.Contains(p.segment2))
                        {
                            var query2 = candIntersection.Where(m => m.lhs.Equals(group.Key)).Concat(candIntersection.Where(m => m.rhs.Equals(group.Key)));
                            var query3 = candIntersection.Where(m => m.lhs.Equals(p.segment1) || m.lhs.Equals(p.segment2) || m.rhs.Equals(p.segment1) || m.rhs.Equals(p.segment2));
                            foundCand.AddRange(query3);

                            foundParallelSet = p;
                            foundTransversal = group.Key;
                            antecedent = Utilities.MakeList<GroundedClause>(p);
                           
                        }
                    }
                }

            }

            
            //TODO: Make sure there will only be one set of intersections found at a time
            if (foundCand.Count() > 1)
            {
                antecedent.AddRange((IEnumerable<GroundedClause>)(foundCand));  //Add the two intersections to antecedent
                ConcreteCongruentAngles cca1;
                ConcreteCongruentAngles cca2;

                int seg1index;
                int seg2index;

                //Match first and second intersection points with first and second segments
                if (foundCand[0].lhs == foundParallelSet.segment1 || foundCand[0].rhs == foundParallelSet.segment1)
                {
                    seg1index = 0;
                    seg2index = 1;
                }
                else
                {
                    seg1index = 1;
                    seg2index = 0;
                }

                
                ConcreteAngle ang1Seg1 = new ConcreteAngle(foundParallelSet.segment1.Point1, foundCand[seg1index].intersect, foundCand[seg2index].intersect);
                ConcreteAngle ang2Seg1 = new ConcreteAngle(foundParallelSet.segment1.Point2, foundCand[seg1index].intersect, foundCand[seg2index].intersect);
                ConcreteAngle ang1Seg2 = new ConcreteAngle(foundParallelSet.segment2.Point1, foundCand[seg2index].intersect, foundCand[seg1index].intersect);
                ConcreteAngle ang2Seg2 = new ConcreteAngle(foundParallelSet.segment2.Point2, foundCand[seg2index].intersect, foundCand[seg1index].intersect);
                
               

                //Decide which angles match, cover perpendicular case
                if (ang1Seg1.measure <= ang2Seg1.measure)
                {
                    if (ang1Seg2.measure <= ang2Seg2.measure)
                    {
                        cca1 = new ConcreteCongruentAngles(ang1Seg1, ang1Seg2, NAME);
                        cca2 = new ConcreteCongruentAngles(ang2Seg1, ang2Seg2, NAME);
                    }
                    else
                    {
                        cca1 = new ConcreteCongruentAngles(ang1Seg1, ang2Seg2, NAME);
                        cca2 = new ConcreteCongruentAngles(ang2Seg1, ang1Seg2, NAME);
>>>>>>> 8397a84bc91d81552eda116a1a78e6dec9a77895
                    }
                }
                else
                {
<<<<<<< HEAD
                    if (ang1Set2.measure <= ang2Set2.measure)
                    {
                        cca1 = new CongruentAngles(ang1Set1, ang2Set2, NAME);
                        cca2 = new CongruentAngles(ang2Set1, ang1Set2, NAME);
                    }
                    else
                    {
                        cca1 = new CongruentAngles(ang1Set1, ang1Set2, NAME);
                        cca2 = new CongruentAngles(ang2Set1, ang2Set2, NAME);
=======
                    if (ang1Seg2.measure <= ang2Seg2.measure)
                    {
                        cca1 = new ConcreteCongruentAngles(ang1Seg1, ang2Seg2, NAME);
                        cca2 = new ConcreteCongruentAngles(ang2Seg1, ang1Seg2, NAME);
                    }
                    else
                    {
                        cca1 = new ConcreteCongruentAngles(ang1Seg1, ang1Seg2, NAME);
                        cca2 = new ConcreteCongruentAngles(ang2Seg1, ang2Seg2, NAME);
>>>>>>> 8397a84bc91d81552eda116a1a78e6dec9a77895
                    }
                }

                //Add the two new congruent angle sets
                newGrounded.Add(new KeyValuePair<List<GroundedClause>, GroundedClause>(antecedent, cca1));
                newGrounded.Add(new KeyValuePair<List<GroundedClause>, GroundedClause>(antecedent, cca2));
<<<<<<< HEAD
=======
            
>>>>>>> 8397a84bc91d81552eda116a1a78e6dec9a77895
            }

            return newGrounded;
        }
    }
}